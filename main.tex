\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{blindtext}
\usepackage{hyperref}
\usepackage{amsmath,epsfig}
\usepackage{amsfonts}
\usepackage[T1]{fontenc}
\usepackage{titling}
\usepackage{commath}
\usepackage{mathtools}
\usepackage{tabu}
\usepackage{booktabs}
\usepackage{bm}
\usepackage{listings}
\newcommand{\RR}{\mathbb{R}}
\DeclarePairedDelimiter\ip{\langle }{\rangle}
\DeclareMathOperator{\proj}{proj}

\setlength{\droptitle}{-10em}
\title{Final report draft}

\begin{document}

\maketitle
\begin{abstract}

\end{abstract}

\section{Introduction}
Ray tracing is a computer graphics technique that creates images by tracing the path of light from a pixel as it intersects with the objects in the scene, and calculate how much light is reflected back along the ray to determine the color of the pixel. Figure 1 illustrate the fundamental precess of ray tracing.

The goal of this project is to quantitatively compare the results of introducing importance sampling in a ray tracing model. Instead of picking a random direction for the next ray in the light path and calculating the BSDF, importance sampling lets the model to automatically select a direction based on how much it will contribute to the radiance, so the insignificant directions are selected less often, resulting in faster convergence rate of the image. In this project, we observe the convergence rate under direct sampling and importance sampling methods by comparing how fast the Frobenius norm of the difference between the converged image and an image generated given difference number of samples.
    
\section{Methods}
\subsection{Introduction: the rendering equation}
The physical basis for all raytracers is the rendering equation, which can be written as\footnote{cite this}
\[L_{o}(\mathbf x, \bm {\omega_{o}}, \lambda, t) = L_{e}(\mathbf x, \bm{\omega_o}, \lambda, t) + \int_\Omega f_s(\mathbf x, \bm{\omega_i}, \bm{\omega_o}, \lambda, t)L_i(\mathbf x, \bm{\omega_i}, \lambda, t)\ip{\bm n, \bm{\omega_i}} \dif \bm{\omega_i}\]

where
\begin{center}
  \begin{tabu}{ll}
    \(L_{o}\) is the outbound radiance & \(\bm{\omega_o}\) is the outbound radiance direction\\
    \(L_{i}\) is the inbound radiance & \(\bm{\omega_i}\) is inbound radiance direction\\
    \(L_{e}\) is the emission radiance & \(\mathbf x\) is a point in space\\
    \(f_s\) bidirectional scattering distribution function & \(\lambda\) is the spectral wavelength\\
    \(\Omega\) is the unit hemisphere around \(\bm n\) & \(\bm n\) is the surface normal at \(\mathbf x\).
  \end{tabu}
\end{center}
Since we are rendering only still images, we can ignore the dependence on time, yielding
\[L_{o}(\mathbf x, \bm {\omega_{o}}, \lambda) = L_{e}(\mathbf x, \bm{\omega_o}, \lambda) + \int_\Omega f_s(\mathbf x, \bm{\omega_i}, \bm{\omega_o}, \lambda)L_i(\mathbf x, \bm{\omega_i}, \lambda)\ip{\bm n, \bm{\omega_i}} \dif \bm{\omega_i}.\]

Solving the rendering equation for a given set of objects is the main task in accurate rendering algorithms.
However, the equation is recursive, as the outbound radiance at one point may become the inbound radiance at another.
Thus, a realistic solution to the rendering equation requires integrating over all possible paths light may take within a scene.
For scenes of any reasonable complexity, this produces a system that is too complex to be solved analytically.

Therefore, it is appropriate to compute an approximate solution to the rendering equation using Monte Carlo methods.
Raytracers operate by explicitly tracing light paths through the scene.
By averaging over enough paths, they can produce a highly accurate approximate solutions to the rendering equation.
In this paper, we have chosen to implement forward path tracing.
In this method, light rays start at the observer and bounce through the scene until they encounter a light.
This is the opposite of the normal intuition involving light, as photons themselves travel from light sources to the observer.
However, due to Helmholtz reciprocity, the result is the same.
The advantage of this method over tracing light from light sources to the observer is that it is easier to control the sampling distribution of rays with respect to the observer, which generally leads to more straightforward convergence.

The path tracing algorithm can be described by the following highly simplified psuedo code
\begin{lstlisting}
def radiance(ray):
    if the recursion depth is above a certain threshold:
        return black
    if the ray does not hit an object in the scene:
        return black
    let obj be the object hit by the ray
    let i be a randomly sampled input ray
    let r be radiance(i)
    add the emission of obj to r
    calculate the spectral output given ray, i, and r
\end{lstlisting}
Accordingly, the focus of this paper will be on intelligent sampling the input ray \(\bm i\) from this description.

\subsection{Calculating reflected light}
\subsubsection{Defining the bidirectional scattering distribution function}
Until this point, the details of the interaction of light at the surface of an object have not been discussed.
The optical properties of a material are defined exclusively by its bidirectional scattering distribution function or BSDF, notated \(f_s\).
The BSDF is a function of four parameters:
\begin{enumerate}
\item \(\mathbf x\) the point in space at which the light hit the object
\item \(\bm{\omega_o}\) the outbound radiance direction
\item \(\bm{\omega_i}\) the inbound radiance direction
\item \(\lambda\) the wavelength
\end{enumerate}
We will operate under the assumption that the BSDF remains uniform across the surface of an object.
Thus, in the context of a specific material, there is no dependence on \(\mathbf x\).
The output of the BSDF is the proportion of light reflected according to the given parameters.

Physical materials often have the property that their BSDF is invariant as \(\bm{\omega_o}\) and \(\bm{\omega_i}\) are both rotated about the surface normal \(\bm n\).
This is known as isotropy, and in this paper we will assume that all materials are isotropic.
Therefore in practice, it is convenient to re-parameterize the BSDF in terms relative to the surface normal \(\bm n\).
\begin{align*}
  \theta_{\bm i} &= \cos^{-1} \ip{\bm{\omega_i}, \bm n}\\
  \theta_{\bm o} &= \cos^{-1} \ip{\bm{\omega_o}, \bm n}\\
  \phi_\Delta &= \cos^{-1}\del{\frac{\del{\bm{\omega_o} - \proj_{\bm n} \bm{\omega_o}} \cdot \del{\bm{\omega_i} - \proj_{\bm n} \bm{\omega_i}}}{\norm{\bm{\omega_o} - \proj_{\bm n} \bm{\omega_o}} \cdot \norm{\bm{\omega_i} - \proj_{\bm n} \bm{\omega_i}}}}
\end{align*}
Thus, \(f_s\) is a function of \(\theta_{\bm i}\), \(\theta_{\bm o}\), and \(\phi_\Delta\) where
\begin{enumerate}
\item \(\theta_{\bm i}\) is the angle off the normal of \(\bm{\omega_i}\)
\item \(\theta_{\bm o}\) is the angle off the normal of \(\bm{\omega_o}\)
\item \(\phi_\Delta\) is the angle between \(\bm{\omega_i}\) and \(\bm{\omega_o}\) about the axis of rotation defined by \(\bm n\)
\end{enumerate}

\subsubsection{Integrating the BSDF with importance sampling}
Returning to the rendering equation, we see that in general while path tracing we have no knowledge of the distribution of \(L_i(\mathbf x, \bm{\omega_i}, \lambda, t)\).
However, since we know the material properties, we have complete knowledge of the distribution of \(f_s(\mathbf x, \bm{\omega_i}, \bm{\omega_o}, \lambda, t)\ip{\bm n, \bm{\omega_i}} = f_s(\theta_{\bm i}, \theta_{\bm o}, \phi_\Delta)\cos \theta_{\bm i}\).
Therefore, we can use the knowledge of the BSDF distribution to perform importance sampling of the light paths while path tracing, allowing the approximation to converge faster.

\subsection{Example: Lambertian Diffuse BSDF}
\subsubsection{BSDF description}
Perhaps the simplest possible BSDF is the Lambertian Diffuse BSDF, which describes an ideal diffuse surface.
\[f_s(\theta_{\bm i}, \theta_{\bm o}, \phi_\Delta) = \frac{\rho_d}{\pi}\]
where \(\rho_d \in \intcc{0,1}\) is the albedo, or normal reflectance of the material.
Thus, the Lambertian BSDF describes completely uniform scattering of light in all directions.
In general, we will assume that diffuse surfaces do not emit light.
Therefore, substitution into the rendering equation yields
\begin{align*}
  L_{o}(\mathbf x, \bm {\omega_{o}}, \lambda)
  &= \rho_d \int_\Omega \frac{1}{\pi} L_i(\mathbf x, \bm{\omega_i}, \lambda)\cos\theta_{\bm i} \dif \bm{\omega_i}\\
  &= \rho_d \int_\Omega \frac{1}{\pi} L_i(\mathbf x, \bm{\omega_i}, \lambda)\cos\theta_{\bm i} \sin\theta_{\bm i}\dif \theta_{\bm i} \dif \phi.
\end{align*}
Thus, we are interested in importance sampling with respect to the PDF
\[P(\theta_{\bm i}, \phi_\Delta) = \frac{1}{\pi}\cos \theta_{\bm i}\sin \theta_{\bm i} = \frac{\sin 2\theta_{\bm i}}{2\pi}\]
\subsubsection{Importance sampling derivation}
Since the BSDF is isotropic, we can ignore \(\phi_\Delta\) completely, and sample purely with respect to \(\theta_{\bm i}\).
Therefore, we can define the PDF with respect to \(\theta_{\bm i}\) only as
\[P(\theta_{\bm i}) = \int_0^{2\pi} P(\theta_{\bm i}, \phi)\dif \phi = \int_0^{2\pi} \frac{\sin 2\theta_{\bm i}}{2\pi} \dif \phi = \sin 2\theta_{\bm i}\]
Now, we can find the CDF of the distribution like so
\begin{align*}
  F(\theta_{\bm i})
  &= \int_0^{\theta_{\bm i}} P(\theta) \dif \theta && \text{definition of CDF}\\
  &= \int_0^{\theta_{\bm i}} \sin 2\theta \dif \theta && \text{substitute}\\
  &= -\frac{1}{2}\cos 2\theta_{\bm i} + \frac{1}{2} && \text{integrate}\\
  &= \sin^2 \theta_{\bm i} && \text{trig identity}
\end{align*}
Now, letting \(\xi_\theta \sim \mathcal{U}(0, 1)\) and inverting the CDF with respect to \(\xi_\theta\) yields
\begin{align*}
  \xi_\theta &= F(\theta_{\bm i}) && \text{setup for CDF inversion}\\
  \xi_\theta &= \sin^2 \theta_{\bm i} && \text{substitute}\\
  \theta_{\bm i} &= \sin^{-1}\sqrt{\xi_\theta} && \text{solve for \(\theta_{\bm i}\)}
\end{align*}
And finally from our isotropy assumption,
\[\phi_\Delta = 2\pi\xi_\phi \]
I am using the Fresnel formulation from PBRT.
\begin{align*}
  r_{\parallel}^2 &= \frac{\del{\eta^2 + \kappa^2}\cos^2 \theta_{\bm i} - 2\eta \cos \theta_{\bm i} + 1}{\del{\eta^2 + \kappa^2}\cos^2 \theta_{\bm i} + 2\eta \cos \theta_{\bm i} + 1}\\
  r_{\perp}^2 &= \frac{\del{\eta^2 + \kappa^2} - 2\eta \cos \theta_{\bm i} + \cos^2 \theta_{\bm i}}{\del{\eta^2 + \kappa^2} + 2\eta \cos \theta_{\bm i} + \cos^2 \theta_{\bm i}}
\end{align*}

\section{Results}

\section{Discussion}

\end{document}
